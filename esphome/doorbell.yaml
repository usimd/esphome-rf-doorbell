esphome:
  name: esphome-rf-doorbell
  friendly_name: Doorbell
  
  on_boot:
    priority: -100
    then:
      - script.execute: determine_wake_source
      - if:
          condition:
            switch.is_on: prevent_sleep_switch
          then:
            - deep_sleep.prevent: deep_sleep_control
      - script.execute: check_battery_status
  
# ESP32-S2 configuration with ESP-IDF framework
esp32:
  board: esp32-s2-saola-1
  framework:
    type: esp-idf
    version: recommended

# Enable logging
logger:
  level: DEBUG
  hardware_uart: UART0
  baud_rate: 115200

# Time component for timestamps
time:
  - platform: homeassistant
    id: esphome_time

api:
  encryption:
    key: !secret doorbell_api_encryption_key
  # Actions callable from Home Assistant
  actions:
    - action: open_door
      then:
        - switch.turn_on: door_opener

ota:
  - platform: esphome
    password: !secret doorbell_ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Doorbell Fallback Hotspot"
    password: !secret doorbell_ap_password

# Global variables for wake source tracking
globals:
  - id: wake_from_external_interrupt
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: first_boot_complete
    type: bool
    restore_value: yes
    initial_value: 'false'

# Advanced deep sleep configuration with multiple wake sources
# ESP32 runs from battery, RFM69 always powered from VBUS
# Wake sources:
#   1. GPIO6 (DIO0) - RF packet received from RFM69
#   2. GPIO13 (BELL_SIGNAL) - Wired doorbell button pressed
#   3. GPIO17 (BQ_INT) - Battery charger interrupt (fault, charge complete, etc.)
#   4. GPIO37 (BAT_ALERT) - Battery low alert from fuel gauge
# Wake behavior:
#   - Periodic wakeup: 3s run time (sensor update + sync)
#   - External interrupt: 30s run time (allow user interaction)
deep_sleep:
  id: deep_sleep_control
  # Wake on doorbell, RF packet, or charger interrupt
  esp32_ext1_wakeup:
    pins:
      - number: GPIO6
      - number: GPIO13
        allow_other_uses: true
      - number: GPIO17
        mode: INPUT_PULLUP
        inverted: true
        allow_other_uses: true
      - number: GPIO37
        mode: INPUT_PULLUP
        inverted: true
        allow_other_uses: true
    mode: ANY_LOW
  # Periodic wake every 30s for battery check and settings sync
  run_duration: 3s    # Short for periodic wakeups (extended by scripts for external wakes)
  sleep_duration: 30s  # 30s periodic wake interval

# I2C Bus configuration
i2c:
  # Bus 1: Battery charger BQ25628E
  - id: i2c_bus1
    sda: GPIO16
    scl: GPIO15
    scan: true
    frequency: 1MHz
    
  # Bus 2: Fuel gauge MAX17260
  - id: i2c_bus2
    sda: GPIO36
    scl: GPIO35
    scan: true
    frequency: 1MHz

# SPI Bus for RFM69
spi:
  - id: spi_bus
    clk_pin: GPIO8
    mosi_pin: GPIO10
    miso_pin: GPIO9

# GPIO definitions
binary_sensor:
  # Battery alert from fuel gauge
  - platform: gpio
    name: "Battery Alert"
    id: battery_alert_pin
    pin:
      number: GPIO37
      mode: INPUT_PULLUP
      inverted: true
      allow_other_uses: true
    on_press:
      then:
        - homeassistant.service:
            service: notify.notify
            data:
              message: "Doorbell battery low!"

  # Doorbell button press detection
  - platform: gpio
    name: "Bell Signal"
    id: bell_signal
    pin:
      number: GPIO13
      allow_other_uses: true
      mode: INPUT_PULLUP
      inverted: true
    on_press:
      then:
        - globals.set:
            id: wake_from_external_interrupt
            value: 'true'
        - script.execute: handle_doorbell_press

  # Battery charger interrupt pin
  - platform: gpio
    name: "Charger Interrupt"
    id: charger_interrupt
    internal: true
    pin:
      number: GPIO17
      mode: INPUT_PULLUP
      inverted: true
      allow_other_uses: true
    on_press:
      then:
        - globals.set:
            id: wake_from_external_interrupt
            value: 'true'
        - script.execute: handle_charger_interrupt

  # Battery charger status sensors
  - platform: template
    name: "Charger Thermal Regulation"
    id: charger_thermal_regulation
    icon: "mdi:thermometer-alert"
    lambda: 'return id(battery_charger).is_in_thermal_regulation();'

  - platform: template
    name: "Charger VINDPM Regulation"
    id: charger_vindpm_regulation
    icon: "mdi:flash-alert"
    lambda: 'return id(battery_charger).is_in_vindpm_regulation();'

  - platform: template
    name: "Charger IINDPM Regulation"
    id: charger_iindpm_regulation
    icon: "mdi:current-ac"
    lambda: 'return id(battery_charger).is_in_iindpm_regulation();'

  - platform: template
    name: "Charger Fault"
    id: charger_fault
    device_class: problem
    lambda: 'return id(battery_charger).has_fault();'

switch:
  # Prevent deep sleep for OTA updates (persists across reboots)
  - platform: template
    name: "Prevent Sleep for OTA"
    id: prevent_sleep_switch
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: "mdi:sleep-off"
    on_turn_on:
      - deep_sleep.prevent: deep_sleep_control
    on_turn_off:
      - deep_sleep.allow: deep_sleep_control

  # Manual RF module power control
  - platform: gpio
    name: "RF Power"
    id: rf_power
    pin:
      number: GPIO21
      mode: OUTPUT
      inverted: false
    restore_mode: RESTORE_DEFAULT_ON
    icon: "mdi:radio-tower"

  # Control for muting the bell
  - platform: gpio
    name: "Bell Mute"
    id: bell_off
    pin:
      number: GPIO12
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF

  # Battery charger enable/disable
  - platform: template
    name: "Battery Charging Enable"
    id: charging_enable_switch
    icon: "mdi:battery-charging"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      - lambda: 'id(battery_charger).set_charging_enabled(true);'
    turn_off_action:
      - lambda: 'id(battery_charger).set_charging_enabled(false);'

  # HIZ mode switch (high impedance - disconnects input)
  - platform: template
    name: "Charger HIZ Mode"
    id: hiz_mode_switch
    icon: "mdi:power-plug-off"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: 'id(battery_charger).set_hiz_mode(true);'
    turn_off_action:
      - lambda: 'id(battery_charger).set_hiz_mode(false);'
  
  # Control to trigger door buzzer/opener
  - platform: gpio
    name: "Door Opener"
    id: door_opener
    pin:
      number: GPIO14  # OPEN_BUZZER
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - delay: 3s
        - switch.turn_off: door_opener
  


# Custom components from GitHub repository
external_components:
  - source:
      type: git
      url: https://github.com/usimd/esphome-rf-doorbell
      ref: main
    components: [bq25628e, max17260, rfm69]
    refresh: 1s

# BQ25628E Battery Charger Component
bq25628e:
  id: battery_charger
  i2c_id: i2c_bus1
  address: 0x6A
  update_interval: 60s
  ts_monitoring_enabled: true
  # Charging current and voltage limits
  charge_current_limit: 0.16  # 160mA for 350mAh battery (0.5C rate)
  charge_voltage_limit: 4.2  # Maximum safe voltage for Li-ion
  input_current_limit: 0.16  # 160mA - limited by F1 250mA polyfuse
  input_voltage_limit: 7.5  # 7.5V VINDPM
  # System and pre-charge configuration
  minimum_system_voltage: 3.52
  precharge_current: 0.03
  termination_current: 0.02
  # Charge termination and protection
  termination_enabled: true
  vindpm_battery_tracking: false  # Disable - use fixed threshold
  recharge_threshold: 0.1
  watchdog_timeout: 1
  thermal_regulation_threshold: 120
  # Device information (diagnostic)
  part_number:
    name: "Charger Part Number"
  device_revision:
    name: "Charger Revision"
  # Voltage sensors
  bus_voltage:
    name: "Bus Voltage"
  battery_voltage:
    name: "Battery Voltage"
  system_voltage:
    name: "System Voltage"
  # Current sensors
  charge_current:
    name: "Charge Current"
  input_current:
    name: "Input Current"
  # Temperature sensors
  ts_voltage:
    name: "TS Pin Voltage"
  die_temperature:
    name: "Charger Die Temperature"

# MAX17260 Fuel Gauge Component  
max17260:
  id: fuel_gauge
  i2c_id: i2c_bus2
  address: 0x36
  update_interval: 30s
  voltage:
    name: "Battery Voltage (Fuel Gauge)"
  current:
    name: "Battery Current"
  state_of_charge:
    name: "Battery Percentage"
  remaining_capacity:
    name: "Battery Remaining Capacity"
  full_capacity:
    name: "Battery Full Capacity"
  cycle_count:
    name: "Battery Cycle Count"
  time_to_empty:
    name: "Battery Time to Empty"
  time_to_full:
    name: "Battery Time to Full"
  temperature:
    name: "Battery Temperature"
  device_name:
    name: "Fuel Gauge Device Name"
  serial_number:
    name: "Fuel Gauge Serial Number"

# RFM69 Transceiver Component
#rfm69:
#  id: rf_transceiver
#  spi_id: spi_bus
#  cs_pin: GPIO11  # RF.CE
#  reset_pin: GPIO7  # RF.Reset
#  interrupt_pin: GPIO6  # RF.IO0 (DIO0)
#  frequency: 433.0  # 433 MHz ISM band
#  node_id: 1
#  network_id: 100
#  encryption_key: "!secret rf_encryption_key"
#  is_high_power: false  # RFM69W (not RFM69HW)
#  use_challenge_response: true  # Enable challenge-response for replay protection
#  challenge_timeout: 30s  # Challenge expires after 30 seconds
#  on_packet_received:
#    then:
#      - script.execute: handle_rf_packet

# Sensors exposed to Home Assistant
sensor:
  # WiFi Signal Strength
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s
  
  # Uptime
  - platform: uptime
    name: "Uptime"
    update_interval: 60s

text_sensor:
  # Device info
  - platform: version
    name: "ESPHome Version"
  
  # Wake source tracking
  - platform: template
    name: "Last Wake Source"
    id: wake_source
    icon: "mdi:sleep-off"
    update_interval: never
  
  # Battery charger status
  - platform: template
    name: "Charger Status"
    id: charger_status
    icon: "mdi:battery-charging"
    lambda: |-
      uint8_t status = id(battery_charger).get_charge_status();
      switch(status) {
        case 0: return {"Not Charging"};
        case 1: return {"Fast Charging"};
        case 2: return {"Taper Charging"};
        case 3: return {"Top-off Charging"};
        default: return {"Unknown"};
      }

# Number entities for configurable charge parameters
number:
  - platform: template
    name: "Charge Current Limit"
    id: charge_current_setting
    icon: mdi:current-dc
    unit_of_measurement: "A"
    min_value: 0.04
    max_value: 2.0
    step: 0.04
    initial_value: 0.16  # Match bq25628e config
    optimistic: true
    restore_value: true
    mode: slider
    on_value:
      then:
        - lambda: 'id(battery_charger).set_charge_current(x);'
  
  - platform: template
    name: "Charge Voltage Limit"
    id: charge_voltage_setting
    icon: mdi:flash
    unit_of_measurement: "V"
    min_value: 3.5
    max_value: 4.8
    step: 0.01
    initial_value: 4.2  # Match bq25628e config
    optimistic: true
    restore_value: true
    mode: slider
    on_value:
      then:
        - lambda: 'id(battery_charger).set_charge_voltage(x);'
  
  - platform: template
    name: "Input Current Limit"
    id: input_current_setting
    icon: mdi:current-ac
    unit_of_measurement: "A"
    min_value: 0.1
    max_value: 3.2
    step: 0.1
    initial_value: 0.16  # 160mA - limited by F1 250mA polyfuse
    optimistic: true
    restore_value: true
    mode: slider
    on_value:
      then:
        - lambda: 'id(battery_charger).set_input_current(x);'
  
  - platform: template
    name: "Input Voltage Limit"
    id: input_voltage_setting
    icon: mdi:flash-triangle
    unit_of_measurement: "V"
    min_value: 3.8
    max_value: 16.8
    step: 0.04
    initial_value: 7.5  # 7.5V VINDPM threshold
    optimistic: true
    restore_value: true
    mode: slider
    on_value:
      then:
        - lambda: 'id(battery_charger).set_input_voltage(x);'

# Scripts for handling events
script:
  # Determine wake source and set appropriate duration
  - id: determine_wake_source
    then:
      - lambda: |-
          auto wakeup_cause = esp_sleep_get_wakeup_cause();
          
          if (wakeup_cause == ESP_SLEEP_WAKEUP_EXT1) {
            uint64_t wakeup_pin_mask = esp_sleep_get_ext1_wakeup_status();
            
            if (wakeup_pin_mask & (1ULL << 6)) {
              id(wake_source).publish_state("RF Packet");
            } else if (wakeup_pin_mask & (1ULL << 13)) {
              id(wake_source).publish_state("Doorbell Button");
            } else if (wakeup_pin_mask & (1ULL << 17)) {
              id(wake_source).publish_state("Charger Interrupt");
            } else {
              id(wake_source).publish_state("External Interrupt");
            }
            
            id(wake_from_external_interrupt) = true;
          } else if (wakeup_cause == ESP_SLEEP_WAKEUP_TIMER) {
            id(wake_source).publish_state("Periodic Timer");
            id(wake_from_external_interrupt) = false;
          } else {
            id(wake_source).publish_state("Power On");
            id(wake_from_external_interrupt) = false;
          }
  
  - id: handle_doorbell_press
    then:
      - homeassistant.event:
          event: esphome.doorbell_ring
          data:
            device: esphome-rf-doorbell
            timestamp: !lambda 'return id(esphome_time).now().timestamp;'
      - homeassistant.service:
          service: notify.notify
          data:
            title: "ðŸ”” Doorbell"
            message: "Someone is at the door!"
      - deep_sleep.prevent: deep_sleep_control
      - delay: 30s
      - globals.set:
          id: wake_from_external_interrupt
          value: 'false'
      - deep_sleep.allow: deep_sleep_control
  
  - id: handle_charger_interrupt
    then:
      - component.update: battery_charger
      - lambda: |-
          // BQ25628E interrupt flag registers (auto-clear on read)
          uint8_t flag0, flag1, fault_flag;
          if (id(battery_charger).read_register_byte(0x20, &flag0)) {  // CHARGER_FLAG_0
            if (flag0 & 0x20) ESP_LOGW("charger", "Thermal regulation active");
            if (flag0 & 0x08) ESP_LOGW("charger", "IINDPM regulation");
            if (flag0 & 0x04) ESP_LOGW("charger", "VINDPM regulation");
          }
          if (id(battery_charger).read_register_byte(0x21, &flag1)) {  // CHARGER_FLAG_1
            if (flag1 & 0x08) ESP_LOGI("charger", "Charge status changed");
            if (flag1 & 0x01) ESP_LOGI("charger", "VBUS status changed");
          }
          if (id(battery_charger).read_register_byte(0x22, &fault_flag)) {  // FAULT_FLAG_0
            if (fault_flag & 0x80) ESP_LOGE("charger", "VBUS fault");
            if (fault_flag & 0x40) ESP_LOGE("charger", "Battery fault");
            if (fault_flag & 0x20) ESP_LOGE("charger", "VSYS fault");
            if (fault_flag & 0x08) ESP_LOGE("charger", "Thermal shutdown");
          }
      - deep_sleep.prevent: deep_sleep_control
      - delay: 10s
      - globals.set:
          id: wake_from_external_interrupt
          value: 'false'
      - deep_sleep.allow: deep_sleep_control
  
#  - id: handle_rf_packet
#    then:
#      - logger.log: "RF packet received"
#      - lambda: |-
#          // Process RF packet and trigger door opener if valid
#          auto &rfm = id(rf_transceiver);
#          if (rfm.is_valid_remote()) {
#            id(door_opener).turn_on();
#          }
#      - deep_sleep.prevent: deep_sleep_control
#      - delay: 5s
#      - deep_sleep.allow: deep_sleep_control
  
  - id: check_battery_status
    then:
      - component.update: battery_charger
      - component.update: fuel_gauge

# Diagnostics
button:
  - platform: restart
    name: "Restart"

  - platform: template
    name: "Reset Charger Watchdog"
    id: reset_watchdog_button
    icon: "mdi:timer-refresh"
    on_press:
      - lambda: 'id(battery_charger).reset_watchdog();'

  - platform: template
    name: "Reset Charger Registers"
    id: reset_charger_button
    icon: "mdi:restore"
    on_press:
      - lambda: 'id(battery_charger).reset_registers();'
