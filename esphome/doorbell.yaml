esphome:
  name: esphome-rf-doorbell
  friendly_name: Doorbell
  
  on_boot:
    - priority: 800  # VERY early - before most components initialize
      then:
        - lambda: |-
            // Enable internal pullup on GPIO33 for RF LDO enable
            // Using pullup instead of active drive for more reliable voltage level
            gpio_config_t io_conf = {};
            io_conf.pin_bit_mask = (1ULL << GPIO_NUM_33);
            io_conf.mode = GPIO_MODE_OUTPUT_OD;  // Open-drain with pullup
            io_conf.pull_up_en = GPIO_PULLUP_ENABLE;
            io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
            gpio_config(&io_conf);
            gpio_set_level(GPIO_NUM_33, 1);  // Release to pullup
            ESP_LOGI("boot", "GPIO33 pullup enabled for RF LDO");
            
            // Drive GPIO18 LOW for charger CE (active low enable)
            io_conf.pin_bit_mask = (1ULL << GPIO_NUM_18);
            io_conf.mode = GPIO_MODE_OUTPUT;
            io_conf.pull_up_en = GPIO_PULLUP_DISABLE;
            gpio_config(&io_conf);
            gpio_set_level(GPIO_NUM_18, 0);
            ESP_LOGI("boot", "GPIO18 set LOW for charger CE");
    - priority: 600
      then:
        - output.turn_off: charger_ce_pin
        - switch.turn_on: rf_power  # Use switch to sync HA state
        - lambda: |-
            ESP_LOGI("boot", "GPIO33 level after switch.turn_on: %d", gpio_get_level(GPIO_NUM_33));
    - priority: -100  # Runs last after all components initialized
      then:
        - script.execute: check_battery_status
  
# ESP32-S2 configuration with ESP-IDF framework
esp32:
  board: esp32-s2-saola-1
  framework:
    type: esp-idf
    version: recommended

# Enable logging
logger:
  level: DEBUG
  hardware_uart: UART0
  baud_rate: 115200

# Time component for timestamps
time:
  - platform: homeassistant
    id: esphome_time

api:
  encryption:
    key: !secret doorbell_api_encryption_key
  # Actions callable from Home Assistant
  actions:
    - action: open_door
      then:
        - switch.turn_on: door_opener

ota:
  - platform: esphome
    password: !secret doorbell_ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true      # Skip AP scan on reconnect
  output_power: 15dB      # Reduced from 20dB default - saves power

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Doorbell Fallback Hotspot"
    password: !secret doorbell_ap_password

# Custom components from GitHub repository
external_components:
  - source:
      type: git
      url: https://github.com/usimd/esphome-rf-doorbell
      ref: main
    components: [bq25628e, max17260, rfm69]
    refresh: 1s

# =============================================================================
# Power Budget - Always Active Mode
# =============================================================================
# Input: 160mA max from doorbell transformer (limited by BQ25628E IINDPM)
#
# Constant loads (from VBUS):
#   - ESP32-S2 (WiFi LIGHT mode):  ~25mA  (modem sleep between beacons)
#   - RFM69W RX mode:              ~16mA  (always listening)
#   - TLP2391 Schmitt trigger:      ~1.5mA (doorbell detection)
#   - BQ25628E quiescent:           ~0.5mA
#   - TPS629206 buck (Iq):          ~0.02mA
#   - TPS7A2033 LDO (Iq):           ~0.001mA
#   - MAX17260 fuel gauge:          ~0.05mA
#   - Misc (dividers, pull-ups):    ~0.3mA
#   - Total system load:           ~44mA
#
# Available for battery charging:  160 - 44 = ~116mA average
# Charge time (350mAh emptyâ†’full): ~3 hours
#
# Note: WiFi TX bursts draw 80-120mA peak, handled by battery buffer.
#       BQ25628E dynamically adjusts charge current during peaks.
# =============================================================================

# I2C Bus configuration
i2c:
  # Bus 1: Battery charger BQ25628E
  - id: i2c_bus1
    sda: GPIO16
    scl: GPIO15
    scan: true
    frequency: 1MHz
    
  # Bus 2: Fuel gauge MAX17260
  - id: i2c_bus2
    sda: GPIO36
    scl: GPIO35
    scan: true
    frequency: 400kHz

# SPI Bus for RFM69
spi:
  - id: spi_bus
    clk_pin: GPIO8
    mosi_pin: GPIO10
    miso_pin: GPIO9

# Charger CE pin - must be LOW for charging to be enabled
# Hardware has 10k pulldown but ESP32 GPIO leakage pulls it up to ~1V
# Using output platform provides solid ground reference with no power draw
output:
  - platform: gpio
    id: charger_ce_pin
    pin:
      number: GPIO18
      mode:
        output: true

  - platform: gpio
    id: rf_power_pin
    pin:
      number: GPIO33
      mode:
        output: true
        # Internal pullup keeps LDO ON without GPIO drive current
        # When ESP is in deep sleep, pullup maintains HIGH state

# GPIO definitions
binary_sensor:
  # Battery alert from fuel gauge
  - platform: gpio
    name: "Battery Alert"
    id: battery_alert_pin
    disabled_by_default: true
    pin:
      number: GPIO21
      mode: INPUT_PULLUP
      inverted: true
    on_press:
      then:
        - homeassistant.action:
            service: notify.notify
            data:
              message: "Doorbell battery low!"

  # Doorbell button press detection
  - platform: gpio
    name: "Bell Signal"
    id: bell_signal
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
      inverted: true
    on_press:
      then:
        - script.execute: handle_doorbell_press

  # Battery charger interrupt pin
  - platform: gpio
    name: "Charger Interrupt"
    id: charger_interrupt
    internal: true
    pin:
      number: GPIO17
      mode: INPUT_PULLUP
      inverted: true
    on_press:
      then:
        - script.execute: handle_charger_interrupt

  # Battery charger status sensors
  - platform: template
    name: "Charger Thermal Regulation"
    id: charger_thermal_regulation
    disabled_by_default: true
    icon: "mdi:thermometer-alert"
    lambda: 'return id(battery_charger).is_in_thermal_regulation();'

  - platform: template
    name: "Charger VINDPM Regulation"
    id: charger_vindpm_regulation
    disabled_by_default: true
    icon: "mdi:flash-alert"
    lambda: 'return id(battery_charger).is_in_vindpm_regulation();'

  - platform: template
    name: "Charger IINDPM Regulation"
    id: charger_iindpm_regulation
    disabled_by_default: true
    icon: "mdi:current-ac"
    lambda: 'return id(battery_charger).is_in_iindpm_regulation();'

  - platform: template
    name: "Charger Fault"
    id: charger_fault
    disabled_by_default: true
    device_class: problem
    lambda: 'return id(battery_charger).has_fault();'

switch:
  # Manual RF module power control (uses output component for clean drive)
  # RF module is always ON for passive listening - consumes ~16mA in RX mode
  - platform: template
    name: "RF Power"
    id: rf_power
    icon: "mdi:radio-tower"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      - output.turn_on: rf_power_pin
    turn_off_action:
      - output.turn_off: rf_power_pin

  # Control for muting the bell
  - platform: gpio
    name: "Bell Mute"
    id: bell_off
    pin:
      number: GPIO12
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF

  # Battery charger enable/disable
  - platform: template
    name: "Battery Charging Enable"
    id: charging_enable_switch
    disabled_by_default: true
    icon: "mdi:battery-charging"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      - lambda: 'id(battery_charger).set_charging_enabled(true);'
    turn_off_action:
      - lambda: 'id(battery_charger).set_charging_enabled(false);'

  # HIZ mode switch (high impedance - disconnects input)
  - platform: template
    name: "Charger HIZ Mode"
    id: hiz_mode_switch
    disabled_by_default: true
    icon: "mdi:power-plug-off"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: 'id(battery_charger).set_hiz_mode(true);'
    turn_off_action:
      - lambda: 'id(battery_charger).set_hiz_mode(false);'
  
  # Control to trigger door buzzer/opener
  - platform: gpio
    name: "Door Opener"
    id: door_opener
    pin:
      number: GPIO14  # OPEN_BUZZER
      mode: OUTPUT
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      then:
        - delay: 5s
        - switch.turn_off: door_opener

  # RF Remote Pairing Mode - enable to allow new remotes to register
  # SECURITY: Only enable when actively pairing a new remote!
  - platform: template
    name: "RF Pairing Mode"
    id: rf_pairing_mode
    icon: "mdi:link-plus"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - lambda: 'id(rf_transceiver).set_pairing_mode(true);'
      # Auto-disable after 60 seconds for security
      - delay: 60s
      - switch.turn_off: rf_pairing_mode
    on_turn_off:
      - lambda: 'id(rf_transceiver).set_pairing_mode(false);'

# BQ25628E Battery Charger Component
bq25628e:
  id: battery_charger
  i2c_id: i2c_bus1
  address: 0x6A
  update_interval: 10s
  ts_monitoring_enabled: true
  # Charging current and voltage limits
  charge_current_limit: 0.16  # 160mA for 350mAh battery (0.5C rate)
  charge_voltage_limit: 4.2  # Maximum safe voltage for Li-ion
  input_current_limit: 0.16  # 160mA - limited by F1 250mA polyfuse
  input_voltage_limit: 7.5  # 7.5V VINDPM
  # System and pre-charge configuration
  minimum_system_voltage: 3.52
  precharge_current: 0.03
  termination_current: 0.02
  # Charge termination and protection
  termination_enabled: true
  vindpm_battery_tracking: false  # Disable - use fixed threshold
  recharge_threshold: 0.1
  watchdog_timeout: 1
  thermal_regulation_threshold: 120
  # Device information (diagnostic)
  part_number:
    name: "Charger Part Number"
    disabled_by_default: true
  device_revision:
    name: "Charger Revision"
    disabled_by_default: true
  # Voltage sensors
  bus_voltage:
    name: "Bus Voltage"
    disabled_by_default: true
  battery_voltage:
    name: "Battery Voltage"
    disabled_by_default: true
  system_voltage:
    name: "System Voltage"
    disabled_by_default: true
  # Current sensors
  charge_current:
    name: "Charge Current"
    disabled_by_default: true
  input_current:
    name: "Input Current"
    disabled_by_default: true
  # Temperature sensors
  ts_voltage:
    name: "TS Pin Voltage"
    disabled_by_default: true
  die_temperature:
    name: "Charger Die Temperature"
    disabled_by_default: true

# MAX17260 Fuel Gauge Component  
max17260:
  id: fuel_gauge
  i2c_id: i2c_bus2
  address: 0x36
  update_interval: 10s
  voltage:
    name: "Battery Voltage (Fuel Gauge)"
    disabled_by_default: true
  current:
    name: "Battery Current"
    disabled_by_default: true
  state_of_charge:
    name: "Battery Percentage"
    disabled_by_default: true
  remaining_capacity:
    name: "Battery Remaining Capacity"
    disabled_by_default: true
  full_capacity:
    name: "Battery Full Capacity"
    disabled_by_default: true
  cycle_count:
    name: "Battery Cycle Count"
    disabled_by_default: true
  time_to_empty:
    name: "Battery Time to Empty"
    disabled_by_default: true
  time_to_full:
    name: "Battery Time to Full"
    disabled_by_default: true
  temperature:
    name: "Battery Temperature"
    disabled_by_default: true
  device_name:
    name: "Fuel Gauge Device Name"
    disabled_by_default: true
  serial_number:
    name: "Fuel Gauge Serial Number"
    disabled_by_default: true

# RFM69 Transceiver Component
# RadioHead-compatible packet format: [LEN][TO][FROM][ID][FLAGS][DATA...]
# Uses GFSK 250kbps modulation, sync words 0x2D 0xD4
# Security: AES-128 encryption + challenge-response + device pairing
rfm69:
  id: rf_transceiver
  spi_id: spi_bus
  cs_pin: GPIO11        # RF.CE (chip select)
  reset_pin: GPIO7      # RF.Reset
  interrupt_pin: GPIO6  # RF.IO0 (DIO0 = PayloadReady)
  frequency: 433.0      # 433 MHz ISM band
  node_id: 1            # This node's address (receiver)
  network_id: 100       # Sync word 2 (for network isolation)
  is_high_power: false  # RFM69W (not RFM69HW)
  tx_power: 13          # TX power in dBm (-18 to +13 for RFM69W)
  encryption_key: !secret rf_encryption_key  # AES-128 key (16 chars)
  challenge_timeout: 30s  # Challenge valid for 30 seconds
  
  # Called when a device is successfully paired
  on_device_paired:
    - lambda: |-
        ESP_LOGI("rfm69", "New device paired with SN: 0x%08X", serial_number);
    - homeassistant.action:
        service: notify.notify
        data:
          title: "Doorbell"
          message: !lambda |-
            char buf[64];
            snprintf(buf, sizeof(buf), "New RF remote paired: 0x%08X", serial_number);
            return std::string(buf);
  
  # Called when a door open request is received (authorized or not)
  on_door_open_request:
    - lambda: |-
        ESP_LOGI("rfm69", "Door open request from SN 0x%08X - %s", 
                 serial_number, authorized ? "AUTHORIZED" : "DENIED");
    - if:
        condition:
          lambda: 'return authorized;'
        then:
          - switch.turn_on: door_opener
          - homeassistant.action:
              service: notify.notify
              data:
                title: "Doorbell"
                message: "Door opened via RF remote"
  
  # Raw packet handler (for debugging and custom protocols)
  on_packet_received:
    - lambda: |-
        ESP_LOGI("rfm69", "Packet from 0x%02X, RSSI: -%d dBm, len: %d", from_address, rssi, data.size());
    - if:
        condition:
          lambda: 'return data.size() >= 1 && data[0] == 0x10;'
        then:
          - script.execute: handle_doorbell_press

# Sensors exposed to Home Assistant
sensor:
  # WiFi Signal Strength
  - platform: wifi_signal
    name: "WiFi Signal"
    disabled_by_default: true
    update_interval: 60s
  
  # Uptime
  - platform: uptime
    name: "Uptime"
    disabled_by_default: true
    update_interval: 60s

text_sensor:
  # Device info
  - platform: version
    name: "ESPHome Version"
    disabled_by_default: true
  
  # Battery charger status
  - platform: template
    name: "Charger Status"
    id: charger_status
    disabled_by_default: true
    icon: "mdi:battery-charging"
    lambda: |-
      uint8_t status = id(battery_charger).get_charge_status();
      switch(status) {
        case 0: return {"Not Charging"};
        case 1: return {"Fast Charging"};
        case 2: return {"Taper Charging"};
        case 3: return {"Top-off Charging"};
        default: return {"Unknown"};
      }

# Number entities for configurable charge parameters
number:
  - platform: template
    name: "Charge Current Limit"
    id: charge_current_setting
    disabled_by_default: true
    icon: mdi:current-dc
    unit_of_measurement: "A"
    min_value: 0.04
    max_value: 2.0
    step: 0.04
    initial_value: 0.16  # Match bq25628e config
    optimistic: true
    restore_value: false
    mode: slider
    on_value:
      then:
        - lambda: 'id(battery_charger).set_charge_current(x);'
  
  - platform: template
    name: "Charge Voltage Limit"
    id: charge_voltage_setting
    disabled_by_default: true
    icon: mdi:flash
    unit_of_measurement: "V"
    min_value: 3.5
    max_value: 4.8
    step: 0.01
    initial_value: 4.2  # Match bq25628e config
    optimistic: true
    restore_value: false
    mode: slider
    on_value:
      then:
        - lambda: 'id(battery_charger).set_charge_voltage(x);'
  
  - platform: template
    name: "Input Current Limit"
    id: input_current_setting
    disabled_by_default: true
    icon: mdi:current-ac
    unit_of_measurement: "A"
    min_value: 0.1
    max_value: 3.2
    step: 0.1
    initial_value: 0.16  # 160mA - limited by F1 250mA polyfuse
    optimistic: true
    restore_value: false
    mode: slider
    on_value:
      then:
        - lambda: 'id(battery_charger).set_input_current(x);'
  
  - platform: template
    name: "Input Voltage Limit"
    id: input_voltage_setting
    disabled_by_default: true
    icon: mdi:flash-triangle
    unit_of_measurement: "V"
    min_value: 3.8
    max_value: 16.8
    step: 0.04
    initial_value: 7.5  # 7.5V VINDPM threshold
    optimistic: true
    restore_value: false
    mode: slider
    on_value:
      then:
        - lambda: 'id(battery_charger).set_input_voltage(x);'

# Scripts for handling events
script:
  - id: handle_doorbell_press
    mode: single  # Ignore re-triggers while running (debounce)
    then:
      - homeassistant.event:
          event: esphome.doorbell_ring
          data:
            device: esphome-rf-doorbell
            timestamp: !lambda 'return id(esphome_time).now().timestamp;'
      - homeassistant.action:
          service: notify.notify
          data:
            title: "ðŸ”” Doorbell"
            message: "Someone is at the door!"
      # Cooldown period - ignore additional presses for 5 seconds
      - delay: 5s
  
  - id: handle_charger_interrupt
    then:
      - component.update: battery_charger
      - lambda: |-
          // BQ25628E interrupt flag registers (auto-clear on read)
          uint8_t flag0, flag1, fault_flag;
          if (id(battery_charger).read_register_byte(0x20, &flag0)) {  // CHARGER_FLAG_0
            if (flag0 & 0x20) ESP_LOGW("charger", "Thermal regulation active");
            if (flag0 & 0x08) ESP_LOGW("charger", "IINDPM regulation");
            if (flag0 & 0x04) ESP_LOGW("charger", "VINDPM regulation");
          }
          if (id(battery_charger).read_register_byte(0x21, &flag1)) {  // CHARGER_FLAG_1
            if (flag1 & 0x08) ESP_LOGI("charger", "Charge status changed");
            if (flag1 & 0x01) ESP_LOGI("charger", "VBUS status changed");
          }
          if (id(battery_charger).read_register_byte(0x22, &fault_flag)) {  // FAULT_FLAG_0
            if (fault_flag & 0x80) ESP_LOGE("charger", "VBUS fault");
            if (fault_flag & 0x40) ESP_LOGE("charger", "Battery fault");
            if (fault_flag & 0x20) ESP_LOGE("charger", "VSYS fault");
            if (fault_flag & 0x08) ESP_LOGE("charger", "Thermal shutdown");
          }
  
#  - id: handle_rf_packet
#    then:
#      - logger.log: "RF packet received"
#      - lambda: |-
#          // Process RF packet and trigger door opener if valid
#          auto &rfm = id(rf_transceiver);
#          if (rfm.is_valid_remote()) {
#            id(door_opener).turn_on();
#          }
#      - deep_sleep.prevent: deep_sleep_control
#      - delay: 5s
#      - deep_sleep.allow: deep_sleep_control
  
  - id: check_battery_status
    then:
      - component.update: battery_charger
      - component.update: fuel_gauge

# Diagnostics
button:
  - platform: restart
    name: "Restart"
    disabled_by_default: true

  - platform: template
    name: "Reset Charger Watchdog"
    disabled_by_default: true
    id: reset_watchdog_button
    icon: "mdi:timer-refresh"
    on_press:
      - lambda: 'id(battery_charger).reset_watchdog();'

  - platform: template
    name: "Reset Charger Registers"
    id: reset_charger_button
    disabled_by_default: true
    icon: "mdi:restore"
    on_press:
      - lambda: 'id(battery_charger).reset_registers();'

  - platform: template
    name: "Recover from Poor Source Lockout"
    id: recover_source_button
    disabled_by_default: true
    icon: "mdi:power-plug-battery"
    on_press:
      then:
        - logger.log: "Attempting to recover from poor source lockout..."
        # Toggle HIZ mode to simulate adapter removal/plug-in
        - lambda: 'id(battery_charger).set_hiz_mode(true);'
        - delay: 500ms
        - lambda: 'id(battery_charger).set_hiz_mode(false);'
        - delay: 100ms
        # Re-enable charging
        - lambda: 'id(battery_charger).set_charging_enabled(true);'
        - logger.log: "Poor source recovery attempted - check charger status"
        - component.update: battery_charger

  - platform: template
    name: "Dump Charger Registers"
    id: dump_registers_button
    disabled_by_default: true
    icon: "mdi:file-document-outline"
    on_press:
      then:
        - lambda: |-
            // Read and log key registers for debugging
            ESP_LOGI("bq25628e", "=== BQ25628E Register Dump ===");
            uint8_t reg;
            // Control registers
            for (uint8_t addr = 0x02; addr <= 0x19; addr++) {
              if (id(battery_charger).read_register_byte(addr, &reg)) {
                ESP_LOGI("bq25628e", "REG 0x%02X = 0x%02X", addr, reg);
              }
            }
            // Status and flag registers
            for (uint8_t addr = 0x1D; addr <= 0x25; addr++) {
              if (id(battery_charger).read_register_byte(addr, &reg)) {
                ESP_LOGI("bq25628e", "REG 0x%02X = 0x%02X", addr, reg);
              }
            }
            ESP_LOGI("bq25628e", "=== End Register Dump ===");

  # RFM69 diagnostic buttons
  - platform: template
    name: "Dump RF Registers"
    id: dump_rf_registers_button
    disabled_by_default: true
    icon: "mdi:radio"
    on_press:
      - lambda: 'id(rf_transceiver).dump_registers();'

  - platform: template
    name: "Clear All Paired RF Remotes"
    id: clear_paired_remotes
    disabled_by_default: true
    icon: "mdi:link-off"
    on_press:
      - lambda: |-
          id(rf_transceiver).clear_all_paired_devices();
          ESP_LOGW("rfm69", "All paired RF remotes have been cleared!");
      - homeassistant.action:
          service: notify.notify
          data:
            title: "Doorbell"
            message: "All paired RF remotes have been cleared"